local selectors = import 'promql/selectors.libsonnet';

local generateSaturationRulesGroup(
  includePrometheusEvaluated,
  includeDangerouslyThanosEvaluated,
  saturationResources
      ) =
  local selectorHash = if includeDangerouslyThanosEvaluated && !includePrometheusEvaluated then { monitor: 'global' } else {};
  local selector = selectors.serializeHash(selectorHash);

  local saturationResourceNames = std.objectFields(saturationResources);
  local filtered = std.filter(
    function(key)
      local definition = saturationResources[key];
      // Not all saturation metrics will match all architectures, filter our non-matches
      (std.length(definition.appliesTo) > 0)
      &&
      (
        (includePrometheusEvaluated && !definition.dangerouslyThanosEvaluated)
        ||
        (includeDangerouslyThanosEvaluated && definition.dangerouslyThanosEvaluated)
      ),
    saturationResourceNames
  );
  local resourceAutoscalingRuleFiltered = std.filter(
    function(key) std.get(saturationResources[key], 'resourceAutoscalingRule', false),
    filtered
  );

  local rules = std.map(function(key) saturationResources[key].getRecordingRuleDefinition(key), filtered);
  local resourceAutoscalingRules = std.map(function(key) saturationResources[key].getResourceAutoscalingRecordingRuleDefinition(key), resourceAutoscalingRuleFiltered);
  local sloThresholdRecordingRules = std.flatMap(function(key) saturationResources[key].getSLORecordingRuleDefinition(key), filtered);
  local saturationMetadataRecordingRules = std.map(function(key) saturationResources[key].getMetadataRecordingRuleDefinition(key), filtered);
  local saturationAlerts = std.flatMap(function(key) saturationResources[key].getSaturationAlerts(key, selectorHash), filtered);

  local recordedQuantiles = [0.95, 0.99];

  // When generating thanos-only rules, we need to add partial_response_strategy
  local groupBase = if !includePrometheusEvaluated && includeDangerouslyThanosEvaluated then { partial_response_strategy: 'warn' } else {};

  std.map(function(group) groupBase + group, [{
    // Recording rules for each saturation metric
    name: 'Saturation Rules (autogenerated)',
    interval: '1m',
    rules: rules,
  }, {
    // Recording rules for each resource saturation metric for autoscaling
    name: 'Resource Saturation Rules (autogenerated)',
    interval: '1m',
    rules: resourceAutoscalingRules,
  }, {
    // Recording rules defining the soft and hard SLO thresholds
    name: 'GitLab Component Saturation Max SLOs',
    interval: '5m',
    rules: sloThresholdRecordingRules,
  }, {
    // Metadata each of the saturation metrics
    name: 'GitLab Component Saturation Metadata',
    interval: '5m',
    rules: saturationMetadataRecordingRules,
  }, {
    // Alerts for saturation metrics being out of threshold
    name: 'GitLab Component Saturation Statistics',
    interval: '5m',
    rules:
      [
        {
          record: 'gitlab_component_saturation:ratio_quantile%(quantile_percent)d_1w' % {
            quantile_percent: quantile * 100,
          },
          expr: 'quantile_over_time(%(quantile)g, gitlab_component_saturation:ratio{%(selector)s}[1w])' % {
            selector: selector,
            quantile: quantile,
          },
        }
        for quantile in recordedQuantiles
      ]
      +
      [
        {
          record: 'gitlab_component_saturation:ratio_quantile%(quantile_percent)d_1h' % {
            quantile_percent: quantile * 100,
          },
          expr: 'quantile_over_time(%(quantile)g, gitlab_component_saturation:ratio{%(selector)s}[1h])' % {
            selector: selector,
            quantile: quantile,
          },
        }
        for quantile in recordedQuantiles
      ]
      +
      [
        {
          record: 'gitlab_component_saturation:ratio_avg_1h',
          expr: 'avg_over_time(gitlab_component_saturation:ratio{%(selector)s}[1h])' % {
            selector: selector,
          },
        },
      ],
  }, {
    name: 'GitLab Saturation Alerts',
    interval: '1m',
    rules: saturationAlerts,
  }]);

{
  generateSaturationRulesGroup:: generateSaturationRulesGroup,
}
